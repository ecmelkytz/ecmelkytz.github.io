[
  
    {
      "title"       : "Rails: ActiveStorage",
      "category"    : "",
      "tags"        : "coding, rails, research",
      "url"         : "./rails-activestorage.html",
      "date"        : "2018-05-28 11:16:46 +0300",
      "description" : "",
      "content"     : "1. ActiveStorage Nedir?Rails 5.2 ile gelen ActiveStorage özelliği, dosyaları Amazon S3, Google Cloud, Microsoft Azure Cloud gibi cloud bir servise upload etmemizi sağlar.2. Kurulumrails active_storage:installBu çalıştırılan kod active_storage_blobs ve active_storage_attachments tablolarını oluşturan bir migration dosyası ve servis konfigürasyonları için config altında storage.yml dosyası oluşturur.3. ActiveStorage’ın Temel Sınıfları ActiveStorage::Service ActiveStorage::Blob ActiveStorage::Attachment3.1 ActiveStorage::ServiceService sadece baytların hareketinden sorumlu kısımdır. Dosyanın baytlarını bellekten ve browserdan alıp disk’e taşır.class ActiveStorage::Service def upload(key, io, checksum: nil) raise NotImplementedError end def download(key) raise NotImplementedError endendActiveStorage::Service aslında bir patterndir. Sadece bir tane service değil, birden fazla subclass barındırır. Yani ActiveStorage::Service’i direk çağırıp upload/download metodlarını kullanamayız. Onun subclass’larından biriyle çağırabiliriz. Tüm alt sınıflarda upload ve download metodu mevcut çünkü her servis kendi gerçeklemesini farklı bir yol ile yapmaktadır.Disk alt sınıfı: class ActiveStorage::Service::DiskService &lt; ServiceS3 alt sınıf: class ActiveStorage::Service::S3Service &lt; ServiceFarklı bir servis kullanmak istiyorsak bu pattern doğrultusunda oluşturup kullanabiliriz. ActiveStorage şu an Disk, Amazon S3, Microsoft Azure Storage, Google Cloud Storage, Mirror servislerini desteklemektedir.3.1.1 Yeni Servis Konfigürasyonustorage.yml içerisinde default servis olarak Disk kullanılmaktadır. Hangi servisi kullanmak istiyorsak onu belirtmeliyiz. Örneğin Amazon S3 servisini eklemek için aşağıdaki gibi bir düzenleme yapmamız ve aws-sdk-s3 gem’ini Gemfile’a eklememiz gerekmektedir.local: service: Disk root: &lt;%= Rails.root.join('storage') %&gt;amazon: service: S3 access_key_id: \"\" secret_access_key: \"\" region: \"\" bucket: \"\"3.1.2 Mirror Servis ÖzelliğiBirden fazla servisi senkronize olarak mirror servis olarak kullanarak yedekli çalışabiliriz. Bir dosya eklendiğinde veya silindiğinde bütün mirror edilmiş servislere aynı anda yansıtılır. Bu özellik production’da servisler arası geçişi kolaylaştırmak için kullanılabilir.Mirror servis örneği:s3_west_coast: service: S3 access_key_id: \"\" secret_access_key: \"\" ...s3_east_coast: service: S3 access_key_id: \"\" secret_access_key: \"\" ...production: service: Mirror primary: s3_east_coast mirrors: - s3_west_coastDosyalar primary servisden sunulur.3.2 ActiveStorage::BlobBlob; dosya adı, content-type gibi metadataların tutulduğu yerdir. Dosyanın aslı depolama servisinde ya da diskte saklanır. Her blob’un depolama servisinde identifier key’i vardır.create_table :active_storage_blobs do |t| t.string :key, null: false t.string :filename, null: false t.string :content_type t.text :metadata t.bigint :byte_size, null: false t.string :checksum, null: false t.datetime :created_at, null: false t.index [ :key ], unique: trueend3.3 ActiveStorage::AttachmentAttachment, blob ile model arasında bağlantıyı sağlar. Bir blob birden fazla modelle bağlantılı olabilir.create_table :active_storage_attachments do |t| t.string :name, null: false t.references :record, null: false, polymorphic: true, index: false t.references :blob, null: false t.datetime :created_at, null: false t.index [ :record_type, :record_id, :name, :blob_id ], name: \"index_active_storage_attachments_uniqueness\", unique: trueend4. Nasıl dosya eklenir?Car adında bir modelimiz olsun ve araba resimlerini tutmak için dosya upload etmek isteyelim. O halde Rails’de yapacağımız ilk iş bir migration ile modelimize resimleri tutacağımız yeni bir kolon eklemektir. Bu dosya upload yapmak istediğimiz her model için geçerlidir.ActiveStorage ise diğer dosya upload çözümlerinden biraz farklı çalışır. ActiveStorage’da modelinize yeni bir alan eklemenize gerek yok. Dosya ile ilgili bütün bilgiler activestorage install edilirken oluşturulan blobs ve attachments tablolarında tutulmaktadır.4.1 Bir dosya attach etmek için yapılması gerekenlerclass Car &lt; ApplicationRecord has_one_attached :imageend# strong_parametersparams.require(:car).permit(:name, :image)4.2 Birden fazla dosya attach etmek için yapılması gerekenlerclass Car &lt; ApplicationRecord has_many_attached :imagesend# strong_parametersparams.require(:car).permit(:name, images: [])5. Transformation İşlemleriTransforming işlemcilerin(processor) destekleği metodlar ölçüsünde bloblar üzerinde resimlerin varyasyonlarını oluşturabiliriz. Default processor olarak MiniMagick kullanılmaktadır ancak Vips‘de kullanılabilir.Biçimlendirmeyi etkinleştirmek için image_processing gemi kullanılmaktadır. Bununla ilgili pull request.gem 'image_processing', '~&gt; 1.2'Aşağıdaki satır yorumlandığı zaman bir defaya mahsus orijinal blob’un biçimlendirilmiş halinin URL’i oluşturulur ve dosyalarınız nerede tutuluyorsa disk/cloud oraya kaydedilir.&lt;%= image_tag @cat.image.variant(resize: \"100x100\") %&gt;6. Direk UploadActiveStorage bir ruby gemi olmasının yanında bünyesinde javascript kütüphanesi de barındırır. Dosyalarımızı Rails uygulamasına değil de direk cloud bir servise upload etmek istediğimiz zaman bu javascript kodları devreye girmektedir.Blob oluşurken bir identifier key üretilir ve dosya bu key ile cloud servise upload edilir. Resme tekrar ulaşmak istediğimizde bu key ile bağlantı kurulup erişilmektedir. Direk upload işleminde blob oluşturulma ve resmin store edilme sıralamasında değişiklik olur.Direk upload işlemi için&lt;%= form.file_field :images, multiple: true, direct_upload: true %&gt;7. TartışmaRails dosya upload işlemleri için carrierview, paperclip, refine gibi bir çok güzel kütüphaneye sahip. Hepsinin kendi içinde farklı yaklaşımları var. Doğru bir tercih için ihtiyaçlar belirlenmeli ve kütüphanelerin özellik setine bakılarak bir seçim yapılmalıdır.Paperclip geliştiricileri artık Rails’in kendi upload çözümü olan ActiveStorage’ın kullanımını tavsiye ediyor. Paperclip ile ActiveStorage’ı karşılaştıracak olursak dosya validasyonları konusunda ActiveStorage’ın şu an için güzel bir çözümü yok. Bununla ilgili file_validators gibi 3rd party çözüm önerileri var ya da custom validasyon yazılması gerekiyor.“ActiveStrorage’ı kullanalım mı?, ActiveStorage’a geçiş yapalım mı?” tarzında sorulara araştırmalarım sonucunda şöyle bir cevap elde ettim diyebilirim: Uygulamanızda halihazırda kullandığınız bir upload çözümü var ve siz bundan memnunsanız ActiveStorage’a geçiş yapmanız için değerli bir sebebiniz yok demektir. Böyle bir durumda, ActiveStrorage’da bulunan bir özelliği kullanmak istiyorsanız geçiş yapabilirsiniz. Mirror servis özelliği gibi. Yani başka bir upload çözümüne geçiş yapmayı düşünüyorsanız bunu kullanmak istediğiniz özellik bazında karar verin. Eğer yeni bir uygulamaya başlıyorsanız ActiveStorage’ı deneyin.8. Kaynakça http://guides.rubyonrails.org/active_storage_overview.html https://prograils.com/posts/rails-5-2-active-storage-new-approach-to-file-uploads https://skillsmatter.com/skillscasts/11458-introduction-to-active-storage RailsConf 2018: Inside Active Storage https://www.engineyard.com/blog/active-storage http://www.akitaonrails.com/2017/07/07/upcoming-built-in-upload-solution-for-rails-5-2-activestorage http://api.rubyonrails.org/v5.2.0/"
    } ,
  
    {
      "title"       : "Rails: default_scope Kullanmak Kötü Bir Fikir mi?",
      "category"    : "",
      "tags"        : "coding, rails",
      "url"         : "./rails-default-scope-kullanmak-kotu-bir-fikir-mi.html",
      "date"        : "2017-03-12 15:27:27 +0300",
      "description" : "",
      "content"     : "default_scope belirli bir model üzerinde yapılacak tüm işlemler için varsayılan bir kapsam belirtmemizi sağlayan ActiveRecord metodudur.Bu scope’u(kapsamı) modelimizde soft-deletion işlemi yapmak için kullanabiliriz. Soft-delete işlemi için paranioa kullanmanızı ayrıca öneririm. Acts_as_paranoid ile veri silmekten korkmayın başlıklı blog girdimde bundan bahsetmiştim.Aşağıdaki gibi deleted_on kolonunu kullanarak default bir scope oluşturalım.class Animal &lt; ActiveRecord::Base # Eğer bir veri silindiyse `deleted_on` alanı dolu olacak. default_scope where(deleted_on: nil)endAnimal modelinde tanımladığımız default_scope ile silinen kayıtları saklamış ve sadece silinmemiş olan kayıtlarla iş yapmamızı sağlamış olacağız.&gt; Animal.limit(3)=&gt; Animal Load (4.2ms) SELECT `animals`.* FROM `animals` WHERE `animals`.`deleted_on` IS NULL LIMIT 3Bu scope tanımlaması bazı senaryolar için gerçekten kullanışlı bir durum olabilir ancak default_scope kullanımının tehlikeli bir yanı olduğunu da gözardı etmemek gerek. Çünkü bu scope modelimizin (initialization) başlatılmasını etkiler. Yani tüm (all) model kayıtlarımız üzerinde işlem yapmayı engellemiş oluruz.Bir örnek görelim:Animal modelimizin polymorfic bir ilişkiye sahip olduğunu farzedelim ve default_scope ile her zaman type’ı Cat olacak şekilde filtreleyelim.class Animal ActiveRecord::Base belongs_to :genus, polymorphic: true default_scope where(genus_type: 'Cat')endYeni bir Animal oluşturmaya çalıştığımız zaman genus_type‘ı varsayılan olarak Cat olacaktır.&gt; Animal.new=&gt; &lt;Animal id: nil, name: nil, genus_id: nil, genus_type: \"Cat\", created_at: nil, updated_at: nil&gt;Bu tarz yan etkiler bilinmeden/farkına varılmadan kullanılırsa can sıkıcı problemlerin yaşanılması kaçınılmaz olacaktır.Ayrıca default_scope kullandıktan sonra devam sorgularının yazılmasının da zor olduğunu belirtmek isterim.Örneğin modelimizde type’ı Cat olmayanları şu şekilde bulmaya çalışalım:&gt; Animal.where.not(genus_type: 'Cat')Bu query ile istediğimiz sonucu elde edemeyeceğiz. Çünkü default olarak sadece type’ı Cat olanlar baz alınarak query başlatılacaktır. Önceden de bahsettiğim gibi burada initialization’ı etkilemiş oluyoruz. Peki diğer type’lara sahip kayıtlara hiç mi ulaşamayacağız? Elbette bunun da bir yolu var. Bunu sağlamak için ek olarak unscope/unscoped kullanmamız gerekecek.ActiveRecord kapsamlarını nasıl sileriz?Aşağıdaki kapsamlara sahip bir User modelimiz olsun.class User &lt; ActiveRecord::Base scope :active, -&gt; { where(locked: false) } scope :admins, -&gt; { where(role: 'admin') } scope :ordered, -&gt; { order(:name) }end# Tüm kapsamları kullandık&gt; users = User.active.admins.ordered=&gt; SELECT \"users\".* FROM \"users\" WHERE \"users\".\"locked\" = 'f' AND \"users\".\"role\" = 'admin' ORDER BY \"users\".\"name\" ASCKapsamları kaldırmak için unscope ve unscoped metodlarını devreye sokalım:# Tek bir kolon üzerindeki koşulları kaldırmak için&gt; users.unscope(where: :role)=&gt; SELECT \"users\".* FROM \"users\" WHERE \"users\".\"locked\" = 'f' ORDER BY \"users\".\"name\" ASC# Bütün koşulları kaldırmak için&gt; users.unscope(:where)=&gt; SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"name\" ASC# Order kaldırmak için&gt; users.unscope(:order)=&gt; SELECT \"users\".* FROM \"users\" WHERE \"users\".\"locked\" = 'f' AND \"users\".\"role\" = 'admin'# Bütün kapsamları kaldırmak için&gt; users.unscoped=&gt; SELECT \"users\".* FROM \"users\"Bir diğer dikkat etmemiz gereken husus unscoped kullanımı olacak. Çünkü bu query sadece default kapsamları değil tanımlı bütün kapsamları kaldıracaktır. unscoped Rails 3’den beri mevcut ancak unscope Rails 4 ile geldi.Vel hasıl-ı kelam kullanacağımız default_scope‘un kapsamını, uzun vadedeki etkilerini biliyorsak kullanmamızda bir sakınca olmayacaktır."
    } ,
  
    {
      "title"       : "Pervane",
      "category"    : "",
      "tags"        : "şiir",
      "url"         : "./pervane.html",
      "date"        : "2017-02-27 16:44:14 +0300",
      "description" : "",
      "content"     : "Dâr-ı fenanın sanına felek bir kez olsun düşmeyeAhîz eylenen dil-i viran niyet etmez sönmeyeVakti gelmez beklenenin hesabını dürmeyeYanmaya pervane bir sözümüz mü olmasın?Dermanı yaş imiş gönle haşr olanOlmaya cihanda bir kâmı nâr olanBir seni içre öte bir beri yoktan da var olanYanmaya pervane bir gönlümüz mü olmasın?"
    } ,
  
    {
      "title"       : "Rails: Tab menülerde paginate işlemi",
      "category"    : "",
      "tags"        : "coding, rails",
      "url"         : "./rails-tab-manulerde-paginate-islemi.html",
      "date"        : "2016-09-24 09:58:22 +0300",
      "description" : "",
      "content"     : "Tab menülerde paginate işlemini yapılandırırken karşılaştığım sorunlar:İlk önce tablar arasında geçişlerde bir sıkıntı yaşadım. Bunu will_paginate‘in param_name parametresiyle şöyle hallettim.@teachers = Teacher.paginate(page: params[:teachers_page], per_page: 10)@students = Student.paginate(page: params[:students_page], per_page: 10)&lt;%= will_paginate @teachers, param_name: \"teachers_page\" %&gt;&lt;%= will_paginate @students, param_name: \"students_page\" %&gt;Diğer bir sorun ise ilk tab dışındaki diğer tablarda paginate işlemiyle başka sayfalara geçiş yaptığım zaman (?pages=2) sistem sayfayı ilk tab’ın konumuna atıyordu.Yani yapmak istediğim ama aslında olan tam da şu şekildeydi:Bu sorunu da HTML5’in localStorage’ını kullanarak şu şekilde hallettim:# GET /users/1def show @user_activities_for_course_weeks = PublicActivity::Activity.includes(:trackable, :owner).where(owner_id: User.find(params[:id]), trackable_type: \"CourseWeek\").paginate(page: params[:course_weeks], per_page: 10) @user_activities_for_teachers = PublicActivity::Activity.includes(:trackable, :owner).where(owner_id: User.find(params[:id]), trackable_type: \"Teacher\").paginate(page: params[:teachers], per_page: 10)end&lt;ul id=\"activityTab\" class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt;&lt;%= link_to \"Course Weeks\", \"#tab_week\", id: \"profile-tab\", role: \"tab\", \"data-toggle\" =&gt; \"tab\" %&gt;&lt;/li&gt; &lt;li&gt;&lt;%= link_to \"Teachers\", \"#tab_teacher\", role: \"tab\", id: \"profile-tab\", \"data-toggle\" =&gt; \"tab\" %&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class=\"tab-content\"&gt; &lt;%= render \"week_activities\" %&gt; &lt;%= render \"teacher_activities\" %&gt;&lt;/div&gt;&lt;div role=\"tabpanel\" class=\"tab-pane fade active in\" id=\"tab_week\"&gt; &lt;ul class=\"messages\"&gt; &lt;% @user_activities_for_course_weeks.each do |activity| %&gt; &lt;li&gt; ... &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; &lt;%= will_paginate @user_activities_for_course_weeks, class: \"apple_pagination\", param_name: \"course_weeks\" %&gt;&lt;/div&gt;&lt;div role=\"tabpanel\" class=\"tab-pane fade\" id=\"tab_teacher\"&gt; &lt;ul class=\"messages\"&gt; &lt;% @user_activities_for_teachers.each do |activity| %&gt; &lt;li style=\"list-style-type: none;\"&gt; ... &lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt; &lt;%= will_paginate @user_activities_for_teachers, class: \"apple_pagination\", param_name: \"teachers\" %&gt;&lt;/div&gt;$('a[data-toggle=\"tab\"]').on('show.bs.tab', function(e) { localStorage.setItem('activeTab', $(e.target).attr('href'));});var activeTab = localStorage.getItem('activeTab');if (activeTab) { $('#activityTab a[href=\"' + activeTab + '\"]').tab('show');}Farklı çözüm önerileriyle aydınlandığım vakit burayı güncelleyeceğim."
    } ,
  
    {
      "title"       : "Git Komutları",
      "category"    : "",
      "tags"        : "git, github",
      "url"         : "./git-komutlari.html",
      "date"        : "2016-08-11 10:39:24 +0300",
      "description" : "",
      "content"     : "git diffKendi yerelimizde yaptığımız değişiklikler neticesinde, projeyi yönlendirdiğimiz repo arasında oluşan farkları gösterir. Hangi satırı sildiğimiz, hangi satırı eklediğimiz vs. bilgilerini içerir.~/isy$ git diff #Yapılan bütün değişiklikleri gösterecektir.Yapılan bütün değişiklikleri değil de sadece istediğimiz dosya içerisinde nasıl bir değişiklik yapıldığını görmek için o dosyanın adını git diff komutunun yanına eklemeliyiz.~/isy$ git diff README.md #README.md dosyasında yapılan değişiklikleri gösterir.git blameBelirlenen dosyadaki her bir satırın hangi commit ile eklendiği, kimin tarafından ve ne zaman eklendiği bilgilerini gösterir.~/isy$ git blame README.mdgit checkoutDosyalarda yapmış olduğumuz değişiklikleri geri alır. Bu komut ile yapılan değişiklikleri geri aldığımız için git status komutunun ekran çıktısında dosyamızın ismi artık gözükmeyecektir.~/examp-git$ git checkout README.md #README.md dosyasındaki değişiklikleri siler.~/examp-git$ git checkout . #Yapılan bütün değişiklikleri geri alır.git checkout HEAD~ komutu ile projemizi istediğimiz commit durumuna geri döndürebiliriz. Şöyle ki: Projemizin bulunduğu dizinde git log komutunu çalıştırdığımız zaman en son commitden en baştaki committe doğru bütün commitler sıralanacaktır.~/isy$ git logcommit 898de0b8f2d21497569ed980c990d32778e7bd5cAuthor: ecmel &lt;ecmel.kytz@gmail.com&gt;Date: Tue Jul 26 08:57:38 2016 +0300 Hava durumuna yeni açıklama eklecommit 1985f16aa89d41fae740086c53fb1ecefca4affcAuthor: ecmel &lt;ecmel.kytz@gmail.com&gt;Date: Wed Jul 20 12:47:44 2016 +0300 Tasarımsal düzenlemelercommit d44645020926795a4f6b9d74c279632d344543ecAuthor: ecmel &lt;ecmel.kytz@gmail.com&gt;Date: Wed Jul 20 09:20:50 2016 +0300 Excel dosya isimlerinde düzenleme yapEn son commit “Hava durumuna yeni açıklama ekle” iken ben “Excel dosya isimlerinde düzenleme yap” commiti durumuna geçmek istiyorsam çalıştırmam gereken kod: git checkout HEAD~2Geçmek istediğim commit en son commitden(master) kaç commit gerideyse HEAD~ yanına o rakamı koyuyoruz. Sistemi tekrar son haline geri döndürmek için ise git checkout master yazmamız yeterli.git cleangit checkout ile dosyalarda yapılan değişiklikleri geri alabiliyorduk. git clean ile ise yeni eklenen dosyaları silebiliyoruz.~/isy$ git clean -fd #Bütün eklenen yeni dosyaları siler.~/isy$ git clean new_file.txt #new_file adında yeni eklenen dosyayı siler.git reset Söz gelimi yaptığımız değişiklikleri git add . komutu ile izlemeye aldık ve hepsini izlemeden çıkarmak istiyoruz, o halde git reset komutunu kullanmamız gerekmektedir. İzlenen bütün dosyaları değil de sadece bazı dosyaları izlemeden çıkarmak için: git reset HEAD file_name komutu çalıştırılmalı. Yapılan değişiklikler için commit mesajını yazdık ve github’a göndermeden commit mesajını değiştirmek istiyorsak şu komut çalıştırılmalı: ~/isy$ git reset --soft HEAD~Bu komut izlemeyi kaldırmayacaktır. git commit -m \"\" diyerek yeni commit mesajımızı girebiliriz. Github’a gönderdiğimiz son commiti geri almak için:~/isy$ git reset (kalmasını istediğin commit numarası ör:def668e)git push -fBu komutu kullanırken dikkatli olmak gerek zira referans aldığınız commit numarasından önceki bütün commitleri silersiniz. Yani sistemi, referans aldığınız commit durumuna almış olursunuz ve ondan önceki bütün commitleri silersiniz. Silinen commitler ile yapılan değişiklikler sizin yerelinizde gözükür ve tek commit ile tekrar push edebilirsiniz. Çok gerekmediği takdirde birden fazla commiti geri alıp tek commit ile tekrar göndermek projenin gelişim aşaması için anlaşılmazlıklara sebebiyet verebilir. Bu sebeple ben genel itibariyle son attığım commiti değiştirmek için kullanıyorum bu komutu.git stashEn sevdiğim kodlardan bir tanesi. Kısacası yaptığımız değişiklikleri geçici olarak depolamamızı sağlar.Şöyle bir senaryo düşünelim: Uygulamamızdaki bir çok dosyada değişiklik yaptık, yeni dosyalar ekledik vs. ve aniden bir iş çıktı, o işi yapıp biran önce commit etmemiz gerekti. İşte bu tarz durumlarda hangi dosyaları göndereceğinizi eliyip seçmek yerine git stash komutu ile önceden yaptığımız değişiklikleri kaydedip(artık git status ile gözükmeyecekler) acil yapmamız gereken işi yapıp commitleyip eski işimize tekrar dönebiliriz.~/isy$ git stashSaved working directory and index state WIP on master: 898de0b Hava durumuna yeni açıklama ekleHEAD is now at 898de0b Hava durumuna yeni açıklama ekleAcil durum düzenlemelerini yaptıktan sonra yedeklediğimiz diğer işimize şu şekilde dönüyoruz:~/isy$ git stash pop.gitignoreYapılan değişikliklerin takip edilmesini istemediğimiz dosyaları/dosya yollarını .gitignore‘un içerisine ekliyoruz. Ancak .gitignore‘a sonradan eklenen dosya yolları git status ile değişiklik yapılanlar arasında gösterilir. Bu durumu düzeltmek için şu yol izlenir:~/isy$ git rm -r --cached .~/isy$ git add .~/isy$ git commit -m \".gitignore artık düzgün çalışıyor\"Bu komutların yaptığı şey tam olarak şöyle: Takibini yapmasını istemediğiniz dosyalar remote ettiğimiz yerdeki repo’da mevcut olduğu için o dosyaların silinmesini sağlar. O dosyaları sildikten sonra artık yaptığınız değişiklikler izlenmeyecek ve git status ile görüntülenmeyecektir.Repo'daki dosyalar silinmesin ve yaptığım değişiklikler izlenmesin‘i istiyorsak şu işimizi görecektir:git update-index --assume-unchanged FILE_NAME"
    } ,
  
    {
      "title"       : "Rails: Paranoia ile Veri Silmekten Korkmayın",
      "category"    : "",
      "tags"        : "coding, rails",
      "url"         : "./rails-paranoia-ile-veri-silmekten-korkmay%C4%B1n.html",
      "date"        : "2016-04-09 13:58:21 +0300",
      "description" : "",
      "content"     : "“Bu veriyi silersem ileride lazım olur mu?” “Eyvah! Yanlış veriyi sildim şimdi ne yapacağım?”tarzında çeşitlendirilebilen kaygılarınız var ise paranoia gemi imdadınıza yetişecektir.Peki nedir bu paranoia ve nasıl kullanılır?Paranoia silme işleminde soft delete yapmamıza olanak sağlar. Yani veriyi sildiğimiz zaman aslında tam anlamıyla veritabanından o veriyi yok etmiş olmuyoruz.Tabloya type’ı datetime olacak şekilde ekleyeceğimiz deleted_at alanı sayesinde silme işlemi yaptığımız zaman sadece bu kolonun değeri güncellenecek ve silinme zamanı burada tutulacak.Bu plugin Active Record’un sadece destroy metodu üzerinde override yapmaz aynı zamanda find ve count metodları üzerinde de değişiklik yapar. Sql sorgularına deleted_at’i null olanların getirilmesiyle ilgili eklemeler getirecektir.Migration ile modelimize deleted_at alanını ekleyelim:$rails generate migration AddDeletedAtToUsers deleted_at:datetime:indexMigration dosya içeriğimiz:class AddDeletedAtToUsers &lt; ActiveRecord::Migration def change add_column :users, :deleted_at, :datetime add_index :users, :deleted_at end endclass User &lt; ActiveRecord::Base acts_as_paranoid ...endŞimdi bir user silelim:&gt; User.count# =&gt; 2&gt; User.last.destroy# deleted_at güncellenecektir.&gt; User.count# =&gt; 1# Silinen veriler ile birlikte hepsini bulmak için:&gt; User.with_deleted# Sadece silinen verileri bulmak için:&gt; User.only_deletedUser.count kullandığımızda veya find ile o user’ı bulmaya çalıştığımızda user silinmiş gibi davranacaktır ancak veritabanında users tablosuna baktığımız zaman bu silinmiş sandığımız kaydın hala orada durduğunu ve deleted_at alanının verinin silindiği zamanı tuttuğunu göreceğiz.Peki paranoia ile hiçbir zaman veritabanından bir veriyi tam anlamıyla silemeyecek miyiz? Bunun da bir çözümü var. Herşeye rağmen kesinlikle silmek istediğimiz kayıtlar var ise: $User.last.really_destroy!Eğer veritabanında tutacağımız kolon adının deleted_at yerine destroyed_at (veya herhangi birşey) olmasını istiyorsak:class User &lt; ActiveRecord::Base acts_as_paranoid column: :destroyed_at ...endCallback’ler ile kullanımı ve paranoia hakkında daha fazla bilgi için bakınız."
    } ,
  
    {
      "title"       : "Bir Developer&#39;ın Hayatını Kolaylaştıracak 3 Prensip: KISS, YAGNI, DRY",
      "category"    : "",
      "tags"        : "research",
      "url"         : "./bir-developerin-hayatini-kolaylastiracak-3-prensip.html",
      "date"        : "2016-03-27 10:44:16 +0300",
      "description" : "",
      "content"     : "KISS: Keep It Simple, Stupid!Gereksiz karmaşıklıktan uzak durmayı, yazdığımız kodun bizden sonrakilerin kolaylıkla anlayabilmesini/geliştirebilmesini sağlamayı hedefleyen bir prensiptir.Bu ifade Kelly Johnson tarafından kullanılmıştır ve şöyle bir açıklama getirmiştir: Eğer sistemlerinizi kompleks yapmak yerine onları daha basit tutarsanız sisteminiz en iyi şekilde çalışacaktır. Bu nedenle tasarımda hedef nokta basitlik olmalı ve gereksiz karmaşıklıktan kaçınılmalıdır.Diğer açılımlarıKeep It Simple SillyKeep It Short and SimpleKeep It Simple and StraightforwardKeep It Small and SimpleYAGNI: You Aren’t Gonna Need It / Buna İhtiyacın OlmayacakExtreme Programming(XP)’nin prensiplerinden biridir. Proje geliştirirken bazen ileride ihtiyaç olacağını düşündüğümüz bazı ekstra özellikleri şimdiden planlar ve yapmaya başlarız. Bu bizi, ileride kullanılmayacak ya da daha farklı bir şeye ihtiyaç duyacağımız bir durumla karşı karşıya bırakabilir. Bu da ihtiyaç dışı planlama ve kodlama için vakit kaybına neden olmuş olacaktır. Aynı zamanda sistem daha karmaşık hale gelecektir ki bu da KISS prensibine aykırı bir durumdur.DRY: Don’t Repeat Yourself / Kendini Tekrar EtmeRails’in temel prensiplerden biridir. Aynı metodlar/fonksiyonlar sistemimizde farklı yerlerde kullanılıp tekrar ediliyorsa bu prensibe uymuyoruz demektir.Andrew Hunt ve David Thomas, “The Pragmatic Programmer” adlı kitaplarında bu prensipten şöyle söz etmişlerdir: Bir sistem içinde bilginin her bir parçası tek, kesin ve güvenilir olmalıdır.Diğer bir deyişle: Sistemin fonksiyonel davranışları, kodun tek bir parçası içerisinde tutulmaya çalışılmalıdır."
    } ,
  
    {
      "title"       : "Rails: ActiveRecord Enum Usage",
      "category"    : "",
      "tags"        : "coding, rails, ruby",
      "url"         : "./rails-activerecord-enum-usage.html",
      "date"        : "2016-03-10 14:00:01 +0200",
      "description" : "",
      "content"     : "Let’s have a model called Car and we want to keep information such as whether the car is rented, available or unavailable.Should we use more than one column? Why?Let’s imagine that we added these fields to our table as follows.class AddStatusesToCars &lt; ActiveRecord::Migration def change add_column :cars, :rented, :boolean add_column :cars, :available, :boolean add_column :cars, :unavailable, :boolean endendAccording to this scenario, the car must be either rented, available or unavailable. It should not be both rented and available at the same time. We can handle this with validation. However, this time, when one is true, the other two columns will be empty. So let’s look at a way to do this in a single column:class AddStatusToCars &lt; ActiveRecord::Migration def change add_column :cars, :status, :integer, default: 0 endendclass Car &lt; ActiveRecord::Base STATUSES = %w{rented available unavailable} def status_to_s STATUSES[status] end def available? status_to_s == 'available' end def rented? status_to_s == 'rented' end def unavailable? status_to_s == 'unavailable' endendLet’s look at its usage:&gt; Car.first.status_to_s# =&gt; “available”&gt; Car.first.available?# =&gt; true&gt; Car.first.rented?# =&gt; false&gt; Car.first.unavailable?# =&gt; falseThis may be preferable instead of creating three columns. But, how do we solve the process of creating extra methods?Let’s call the Enum into play.Add the status field to our car model:class AddStatusToCars &lt; ActiveRecord::Migration def change add_column :cars, :status, :integer, default: 0 endendDefine our statuses with enum in our car model.class Book &lt; ActiveRecord::Base enum status: [:available, :rented, :unavailable] # or define with number # enum status: [ # available: 1, # rented: 2, # unavailable: 3 # ]endLet’s look at its usage:&gt; car = Car.first&gt; car.status# =&gt; “available”&gt; car.rented?# =&gt; false# Change the car status to rentedcar.status = :rentedcar.rented! # updatedcar.rented?# =&gt; true# To find all rented cars (scope method) &gt; Car.rented# =&gt; SELECT \"cars\".* FROM \"cars\" WHERE \"cars\".\"status\" = ? [[\"status\", 1]]# [#&lt;Car:0x007f41d3eeeeee# id: 1,# status: 1,# ]# To find all unavailable cars (scope method)&gt; Car.unavailable# =&gt; SELECT \"cars\".* FROM \"cars\" WHERE \"cars\".\"status\" = ? [[\"status\", 2]]# =&gt; [] (There isn't any available car)"
    } ,
  
    {
      "title"       : "Two Way Binding - One Time Binding In AngularJS",
      "category"    : "",
      "tags"        : "coding, angularjs",
      "url"         : "./angularjs-two-way-binding-one-time-binding.html",
      "date"        : "2015-08-28 23:31:15 +0300",
      "description" : "",
      "content"     : "Two way binding (çift yönlü veri bağlama) modeldeki değişiklikleri view’e, view’deki değişiklikleri modele aktarma işlemidir. Daha önceki yazımda two way binding ve doğal olarak digest cycle’dan uzun uzadıya bahsetmiştim.Two way binding, kullanıcı etkileşimlerinin direk view kısmına aktarılması kısmında çok güzel bir işleve sahip olsa da; digest cycle tetiklendikten sonra en az 2, maksimum 10 kez çalıştığı düşünülürse performans anlamında büyük sorunlar oluşturacaktır. Şöyle ki; benim data binding sayım arttığı ölçüde $digest loop’un sayısı da artacaktır. Kullanıcı etkileşiminin yoğun olduğu bir sayfada performans anlamında yaşanabilecek sıkıntılar elbette ki kaçınılmaz olacaktır.Hal böyle olunca Angularjs geliştiricileri Angular 1.3 versiyonu ile data binding’den kaynaklanan performans sorunlarını gidermek adına one-time binding’i tanıttılar. One time binding view-model güncelleme işlemini bir kez yapıyor, bundan sonra yapılan etkileşimler herhangi bir şekilde view’e ya da modele yansıtılmıyor. Yani digest cycle bir kez kullanıcı etkileşimlerini dinliyor ve bu sayede güncelleme bir kez yapılmış oluyor.One-time binding nasıl çalışır görelimYukarıdaki gif’den de anlaşılacağı üzere model’de yazdığım yazının ilk karakteri view’e bağlanıyor. Ondan sonraki etkileşimlerde hiçbir şekilde veri bağlama yapılmıyor.Syntax farkına bakalımTwo way binding &lt;p&gt; {{ name }} &lt;/p&gt;One time binding &lt;p&gt; {{ ::name }} &lt;/p&gt;"
    } ,
  
    {
      "title"       : "AngularJS Single Page Application",
      "category"    : "",
      "tags"        : "coding, angularjs",
      "url"         : "./angularjs-single-page-application.html",
      "date"        : "2015-08-15 23:04:08 +0300",
      "description" : "",
      "content"     : "Single page application (SPA), tek bir sayfada sunulan uygulamaların genel adıdır. SPA ile sayfa içinde gezinebilmemiz onu ayrı sayfalara bölmez.Angularjs ile bir single page application nasıl oluşturuluyor. Angular bunun için nasıl bir route mekanizması kullanıyor ona bakalım.var app = angular.module('myApp', ['ngRoute']);app.config(['$routeProvider', function($routeProvider) { $routeProvider. when(\"/home\", { templateUrl: 'home.html' }). when(\"/services\", { templateUrl: 'services.html' }). when(\"/clients\", { templateUrl: 'clients.html' }). otherwise({ redirectTo: '/home' });}]);Uygulamamızın modul’une ngRoute modul’unu dependency olarak belirtiyoruz. Yani modulun bağımlılıklarını belirtiyoruz. Bu sayede ngRoute içindeki her fonksiyonu/servisi kendi uygulamamızda da kullanabiliyoruz.Config sadece Provider’lar için kullanılır. Provider’lar Angularjs’de en gelişmiş servis oluşturma kompanentidir. Buradaki $routeProvider servisi uygulama başlamadan Routing konfigürasyonunu sağlar.$routeProvider sayesinde eğer url isteği /home olursa template olarak home.html kullanılmasını, eğer istek /services olursa template olarak services.html kullanılmasını sağlıyoruz. .otherwise ise olmayan herhangi farklı bir istekte bulunulursa /home url’e yönlendirmek için kullanılmaktadır.&lt;h1&gt;Services Page&lt;/h1&gt;&lt;p&gt;Nobody can give you freedom. If you're a man, you take it.&lt;/p&gt;Angular route yapısı için daha çok ui-router kullanılması tavsiye edilir.&lt;html ng-app=\"myApp\"&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;script src=\"https://code.angularjs.org/1.3.9/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"https://code.angularjs.org/1.3.9/angular-route.js\"&gt;&lt;/script&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#/home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/services\"&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/clients\"&gt;Clients&lt;/a&gt;&lt;/li&gt;&lt;br&gt; &lt;/ul&gt; &lt;div ng-view&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;Angularjs route yapısında # karakteri kullanılır. O yüzden linklerdeki url’lerde # karakteri kullanılmıştır. ng-view aslında Rails’de ki yield ile aynı işlevi görür. Angularda eğer bunu eklemezsek sayfada görüntü oluşmayacaktır.Angular Single Page Application örneğinin plunker adresi."
    } ,
  
    {
      "title"       : "AngularJS Çalışma Mantığı",
      "category"    : "",
      "tags"        : "angularjs, coding",
      "url"         : "./angularjs-calisma-mantigi.html",
      "date"        : "2015-08-11 00:26:37 +0300",
      "description" : "",
      "content"     : "Angularjs ile ilgili beni en çok uğraştıran konu kesinlikle angularjs’in çalışma mantığını anlatmak olacak. Çünkü Angularjs ng-app directive’i gibi basit bir söz dizilimi ile çalışmaya başlayıp, mekanizmayı tam anlamıyla anlamak için içerisine dallandıkça digest cycle, $watch list, two way binding, dirty cheking mekanizmasının birbiri ile alakasının anlatılması gereken bir konu haline geliyor.Eğer bir Angularjs uygulaması oluşturmak istiyorsanız elbetteki ilk yapacağınız iş anguların kütüphanesini projenize eklemek olacaktır. Angularjs’nin sayfanın başına veya sonuna eklenmesinin bir önemi yok çünkü Angularjs uygulaması DomReady olmadan yani tüm scriptler yüklenmeden boot etmiyor.Angularjs uygulamasını başlatmak için ng-app yapısal directive ihtiyacımız vardır. Angularjs yüklendikten sonra uygulamanın başlaması için aranan ilk directive ng-app‘dir. ng-app‘ın bulunduğu etiketin sarmaladığı alanlar arasında Angular uygulaması başlar.&lt;!DOCTYPE html&gt;&lt;html ng-app&gt; &lt;head&gt; &lt;script src=\"https://code.angularjs.org/1.3.9/angular.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;Yukarıdaki kodda ng-app html etiketine eklendiği için bu taglar arasında kalan yer Angularjs uygulaması olarak çalışacaktır. ng-app direktive’i aynı zamanda uygulamanın global scope’u olan $rootScope nesnesini oluşturmaktadır.Yeri gelmişkende belirteyim, ng-app‘in kullanımı W3C standartlarına uymadığı için data-ng-app kullanımı tavsiye edilmektedir.ng-app directive’inden sonra sayfa içerisindeki diğer directiveler aranmaya başlanır. Bulunan direktiveler uygulamaya bind edilir. Bind edilenler $wacth list‘e eklenir. Daha sonrasında digest cycle kullanıcı etkileşimlerini dinlemeye başlar.Digest CycleDigest Cycle uygulamanın view katmanını yani kullanıcının gördüğü ekrandaki verileri güncel tutmakla görevlidir. Kullanıcı tarafından yapılan en ufak bir etkileşimde view’in otomatik güncellenmesini sağlar.Özetle; Digest Cycle kullanıcı etkileşimlerini dinliyor, bir değişiklik var ise view kısmını güncel tutuyor vs. tamam ama bunun sağlanmasında arkada nasıl bir mekanizma çalışıyor asıl buna değinmek ve biraz daha derine inmek istiyorum. Bu olayı two way binding üzerinden anlatacağım.Two Way Binding denilen şey ne, nasıl işler?Yukarıdaki gif görsel olarak two way binding dediğimiz şeydir. Görüldüğü üzere model içerisinde yaptığım her değişiklik bind ettiğim view kısmına anında aktarılıyor. Plunker Code&lt;body ng-app&gt; &lt;input type=\"text\" ng-model=\"name\"&gt; &lt;h1&gt; Merhaba {{ name }} &lt;/h1&gt;&lt;/body&gt;{{ }} işareti angular’da expression olarak adlandırılır ve scope nesnesini view’e bind (bağlamaya) etmeye yarar.Şimdi elimizde bir $watch list adında bir listemizin olduğunu hayal edelim. Biz UI’ye her bind ettiklerimizi bu $watch list‘e $watch nesnesi olarak eklediğimizi düşünelim. Digest cycle kullanıcı etkileşimlerini dinlerken her defasında bu $watch list‘e bakar. Eğer bu $watch‘lardan birinde herhangi bir değişiklik var ise model-view senkronizasyonunu sağlar (two way binding’de olduğu gibi). Bu senkronizasyonu dirty cheking mekanizması ile yapar.Dirty Cheking Mekanizmasi: Bir değerin eski değeri ile yeni değerinin karşılaştırılmasıdır.$watch list oluşturma örneği 1:app.controller('MainController', function($scope) { $scope.foo = \"Foo\"; $scope.bar = \"Bar\";}); Hello {{ bar }}Yukarıdaki örnekte html sayfasında ekran çıktısı olarak “Hello Bar” yazısı gözükecektir. Çünkü {{ bar }} expression’ı scope nesnesini view’e bind edecek. Controller içinde scope’a tanımlanmış bir de foo değişkeni var ancak o view’e bind edilmemiş durumda. İşte bu yüzden $watch list‘e sadece 1 tane $watch nesnesi eklenecek. Digest cycle ile de sadece $scope.bar üzerindeki değişiklikler dinlenecek ve view’e aktarılacak.$watch list oluşturma örneği 2: Name: &lt;input type=\"text\" ng-model=\"name\" /&gt; Password: &lt;input type=\"password\" ng-model=\"password\" /&gt;ng-model directivenin özelliklerinden birisi input nesnesini scope’a bağlamaktır. Yani $scope.name ve $scope.password’un ikiside bind edildiği için $watch list‘e 2 tane $watch nesnesi eklenecek ve digest cycle bu iki inputtaki değişiklikleri dinleyecek.Ufak bilgi: Digest çevirimi tetiklendikten sonra minimum 2 maximum 10 kez çalışır. (Angular 1.4’de 20 kez)Digest Loop $watch list gezerken nasıl bir senaryo izliyor biraz daha bakalım: Hey $watch, senin değerin ne? 9 Pekala, bir değişiklik var mı? (Dirty Checking) Hayır yok. (Herhangi bir değişiklik olmadığı için diğer $watch’a geçer.) Hey sen, senin değerin ne? Foo Bir değişiklik var mı? (Dirty Checking) Evet, önceden Bar’dım. Güzel, o halde DOM’u güncelleyelim. $watch’lar bitene kadar bu çevirim devam eder. $digest loop bittiğinde değişiklik var ise DOM’da değişiklik yapılır.AngularJS çalışma mantığını elimden geldiğince anlatmaya çalıştım. Velhasıl-ı kelam faydalı olması dileğiyle…"
    } ,
  
    {
      "title"       : "AngularJS Nedir?",
      "category"    : "",
      "tags"        : "angularjs",
      "url"         : "./angularjs-nedir.html",
      "date"        : "2015-08-07 22:31:00 +0300",
      "description" : "",
      "content"     : "Google’da çalışan Misko Hevery’nin 2009 yılında şahsi bir projesi olarak başlayan AngularJS şuan açık kaynak olarak yayınlanmakta olup; yüzlerce geliştiriciye ve binlerce kullanıcıya sahip devasa bir frontend geliştirme frameworklerinden biridir. Adındanda anlaşılacağı üzere gelişmiş bir javascript kütüphanesidir.Aslına bakarsanız AngularJS ile Javascript ve Jquery’nin yaptığı herşeyi yapabilirsiniz. Bu noktada Anguları tercih etme meselesine gelirsek; kolaylığı, custom directive özelliği, az kod ile çok iş yapılabilmesi (“Write less do more” her ne kadar Jquery sloganı olsa da…), hızlı response sağlaması vs. şeklinde sayılabilecek bir çok güzelliği barındırmaktadır.Angularjs deyince hepsi olmamakla birlikte akla gelebilecek temel unsurlar yukarıdaki resimde mevcuttur. Hepsinden kabaca söz edip daha detaylı bilgileri başka blog girdilerinde yazmayı düşünüyorum. Angularda two way binding dediğimiz şey çift yönlü veri bağlama yani Model’deki değişiklikleri View’e, View’deki değişiklikleri Model’e aktarma işlemidir. Bir de one time binding var. Bunların izahını sonraya bırakıyorum. Angularda Template dediğimiz şeyler aslında viewlerimizdir. Bir sayfadan başka sayfaya geçildiğinde geri işlemi için eski state’i tutan bir hafızaya (geçmiş bilgisine) ihtiyaç vardır bunu History mekanızması sağlar. Factories, Services ve yukarıdaki resimde olmayan Provider Angular’da servis oluşturma komponentleridir. Angular bünyesinde Jquery’nin Lite versiyonu vardır. Bunu jqLite modülü ile sağlar. Eğer projenizde jquery dosyaları yok ise Angular jqlite modülünü kullanacaktır. Aksi takdirde sistemde yüklü olan jquery dosyasını kullanır. MVC bir design patterndir. Angular ilk başlarda MVC mantığı ile geliştirilmiş ancak daha sonrasında MVVM design patterni kullanılmıştır. Buradaki VM(ViewModel) aynı zamanda angulardaki $scope servisine denkttir. Angularda Directive’ler dışında DOM’a müdahale etmemek gerekiyor. Directive deyince DOM manipülasyonlarının yoğun olarak yapıldığı yer aklımıza gelmeli. Yapısal directiveler anguların kendi bünyesindeki directivelerdir (ng-controller, ng-if, ng-show vs.). Bir de kendimizin oluşturabileceği custom directiveler vardır. Custom directiveler ile kendi Html etiketimizi oluşturup Html’e yeni özellikler ekleyebiliriz. Angular form validasyonlarında benimde severek kullandığım validasyon mekanizmasına sahiptir. Sunucuya gitmeden client tarafında verileri validasyona tabi tutuyoruz. Dependency Injection ise uygulamanın bağımlılıklarının belirtilmesidir. Mesela bir modülde third party kütüphane kullanma ihtiyacı var ise ya da farklı bir modül ile ilişkili ise bunları dependecy olarak module eklememiz gerekmektedir. Angular ile Single Page Application(SPA) oluşturabilirsiniz. SPA imkanıyla beraber angular route kaynaklı bazı SEO problemleri yaşanabilir. Angularda route yapısında # karakteri kullanılır.#/users#/users/newGoogle # işaretinin gerçek bir adres karakteri olmadığını bildiği için bu karakterden sonra ne yazıldıysa yazılsın onu indexlemiyor. =(Yukarıdaki bilgiler detaya inmeden kabaca üstünden geçilerek yazılmıştır. Bu sayfadaki bütün bilgilerin ayrıntısını ilerleyen zamanlarda yazmayı planlıyorum.Son olarak;Angular hızlı response oluşturur dedik. Peki nasıl?Bir web sitesine girmeye çalıştığınızı düşünün. İlk olarak browserdan server’a URL isteğinde bulunuyoruz. Server bize cevap olarak web sayfasını ve assets (Javascript vs.)’i döndürüyor. Daha sonra kullanıcı herhangi bir linke tıkladığında, server’a yine bir istek gidiyor ve dönen cevap ilk dönen cevap ile aynı oluyor. Yani tekrar sayfanın tamamı ve assets yükleniyor.Birde AngularJS ile bu iş nasıl oluyor ona bakalım.Sayfa ilk yüklendiğinde geleneksel senaryo ile aynı responsu alacağız. Ancak kullanıcı bir linke tıkladığında veya başka bir yeni istekte bulunduğunda diğerinde olduğu gibi bütün bir sayfayı ve assets’i yüklemiyor. Önceden oluşturduğu veriden istenilen veriyi JSON data olarak çekiyor. Dolayısıyla istemci-sunucu trafiğini azaltmış olup hızlı bir cevap elde etmiş oluyoruz."
    } ,
  
    {
      "title"       : "SOAP Web Servis ile CURL Kullanımını Bash ile Harmanlama",
      "category"    : "",
      "tags"        : "coding, bash",
      "url"         : "./soap-web-servis-ile-curl-kullanimini-bash-ile-harmanlama.html",
      "date"        : "2015-07-25 12:37:26 +0300",
      "description" : "",
      "content"     : "Terminalden IP öğrenme ve IP adresi sorgulamak (x IP kullanılıyor mu, hangi ülke tarafından kullanıyor vs.) için yazılmış basit bir bash kodudur. Curl ile web servis kullanımını bash ile harmanlar. Can sıkıntısı ürünüdür.Özetle: Atla deve değildir.Dosya içeriği:#!/bin/bashGETGEOIPCONTEXT=\"http://www.webservicex.net/geoipservice.asmx/GetGeoIPContext\"GETGEOIP=\"http://www.webservicex.net/geoipservice.asmx/GetGeoIP\"get_ip() { curl -H \"Accept: application/soap+xml\" -d \"IPAddress=$1\" ${GETGEOIP}}my_ip() { curl -H \"Accept: application/soap+xml\" -d \"IPAddress=$1\" ${GETGEOIPCONTEXT}}$@Terminal’de kullanım:$ geoip my_ip# Ekran çıktısı &lt;ReturnCode&gt;1&lt;/ReturnCode&gt; &lt;IP&gt;193.xxx.xx.xx&lt;/IP&gt; &lt;ReturnCodeDetails&gt;Success&lt;/ReturnCodeDetails&gt; &lt;CountryName&gt;Turkey&lt;/CountryName&gt; &lt;CountryCode&gt;TUR&lt;/CountryCode&gt;$ geoip get_ip 195.xxx.xx.xx# Ekran çıktısı &lt;ReturnCode&gt;1&lt;/ReturnCode&gt; &lt;IP&gt;195.xxx.xx.xx&lt;/IP&gt; &lt;ReturnCodeDetails&gt;Success&lt;/ReturnCodeDetails&gt; &lt;CountryName&gt;Germany&lt;/CountryName&gt; &lt;CountryCode&gt;DEU&lt;/CountryCode&gt;Yazdığımız bash kodunu konsoldan çalışır duruma getirme işine bakalım:$chmod 755 geoipArtık kodun bulunduğu dizinde şu şekilde çalıştırabiliriz.$./geoip my_ipSadece dosya ismiyle çalıştırmak istiyorum. Bundan dolayı sudo ile mc (Midnight Commander) aracılığıyla bash script’i /bin dizinine attım. Aynı işlemi yapabileceğimiz bir çok yol elbette mevcut.Misal:# Taşımak için$ sudo mv path/geoip bin# Kopyalamak için$ sudo cp path/geoip bin[Terminal’de kullanım] kısmında gözüktüğü gibi kodumuz çalışır hale gelecektir."
    } ,
  
    {
      "title"       : "attr_accessor Usage in Ruby",
      "category"    : "",
      "tags"        : "coding, ruby",
      "url"         : "./attr_accessor-usage-in-ruby.html",
      "date"        : "2015-07-03 15:45:44 +0300",
      "description" : "",
      "content"     : "Let’s assume we have a class called Person:class Personendperson = Person.new person.name #=&gt; NoMethodError: undefined method `name' for #&lt;Person:0x000055659b8bfb68&gt;If we don’t define a method called name, we will get an error like above (NoMethodError). So let’s define our method.class Person def name @name # instance variable endendperson = Person.newperson.name # =&gt; nilperson.name = \"Ecmel\" # =&gt; NoMethodError: undefined method `name='We defined the name method, but we can only read it, we cannot assign any value. Let’s define writer method.class Person def name # reader @name end def name=(str) # writer @name = str endendperson = Person.newperson.name = \"Ecmel\"person.name # =&gt; \"Ecmel\"Now we can access and change the value of the instance variable (@name) using the reader and writer methods. So will we define these methods this way every time? Nope! We can use attr_reader for reader methods and attr_writer for writer methods.class Person attr_reader :name attr_writer :nameendWe can also use attr_accessor for reading and writing methods instead of defining them separately. Moreover attr_accessor creates instance variable that called @name.class Person attr_accessor :nameenddef say_hello\"Hello #{@name}\"endperson = Person.newperson.name = \"Ecmel\"person.say_hello # =&gt; \"Hello Ecmel\""
    } ,
  
    {
      "title"       : "Grabc - Terminal Application That Finds Hex and RGB Codes of Colors",
      "category"    : "",
      "tags"        : "",
      "url"         : "./grabc.html",
      "date"        : "2015-06-14 12:44:17 +0300",
      "description" : "",
      "content"     : "While doing research to find the RGB equivalent of a color I saw on the screen, I came across a terminal application called grabc.I can say that it will be very convenient, especially for front-end developers.Setupsudo apt-get install grabcUsageWhen you type grabc into the terminal, the cursor will look like a ‘+’ shape and the hex and RGB code of the color of the place that you clicked will be printed on the screen.$ grabc#f55567245,85,103"
    } ,
  
    {
      "title"       : "Chroma Key Nedir?",
      "category"    : "",
      "tags"        : "research",
      "url"         : "./chroma-key-nedir.html",
      "date"        : "2014-11-29 21:46:50 +0200",
      "description" : "",
      "content"     : "Film çekim setlerinde arkaplanın sadece mavi ya da sadece yeşil renkte olduğunu gördüyseniz ne amaçla bu şekilde yapıldığını merak etmiş olabilirsiniz. Filmlerin böyle bir ortamda çekilmesi Chroma Key tekniğini uygulayabilmek içindir.Teknik olarak chroma key nasıl uygulanır?Chroma Key eşit şekilde aydınlatılmış mavi veya yeşil (tek renk) bir arka plan önünde bulunan bir kişi veya nesnenin, başka bir video görüntüsü veya resim üzerine bindirilmesi esasına dayanır. Blue Screen, Green Screen, Chroma Key, greenbox, bluebox ve CSO (Color Seperation Overlay) terimleri ortak kullanılan terimlerdir ve temelleri aynı esaslara dayanır. Chroma key bir program değil tamamen bir tekniktir.Öncelikle düz yeşil renkli (veya mavi renkli) arkaplanda çekilmesi gereken sahneler çekiliyor ardından post-prodüksiyon(çekimler bittikten sonra çekim üzerinde yapılan düzenlemeler) aşamasında özel bilgisayar programları aracılığıyla bu tek renk arkaplan anahtar renk olarak seçilip siliniyor (transparan yapılıyor) ve yerine konulması istenen görüntü giydiriliyor.Görüntüdeki renkli arkaplanı (greenscreen, bluescreen) silme işlemine “key”lemek denir.Chroma Key Tarihi Chroma key ilk olarak Larry Butler tarafından 1940 yılında çekilmiş Bağdat Hırsızı (The Thief of Bagdad) filminde kullanılmış ve daha sonra bu tekniği geliştiren Petro Vlahos’a Oscar ödülü kazandırmıştır. Aynı zamanda 1940 yılından beri chroma key tekniği için yeşil ve mavi renkler standart olarak kullanılmaktadır.Neden Genellikle Mavi ya da Yeşil Renk Kullanılır?Aslında arkaplan rengi olarak yeşil ve mavi renkler dışında başka renklerde kullanılabilir. Ancak buradaki amaç insan tenine en uzak renklerin seçilmesidir. Eğer siyah renk, anahtar renk olarak seçilirse ve bu renk üzerine görüntü bindirilirse kişinin veya nesnenin üzerinde bulunan siyah renkli yerler üzerine de görüntü binecektir. Böylece kişiler ve nesneler üzerinde görüntü bozuklukları yaşanacaktır. Bu yüzden chroma key tekniğinde anahtar renk seçerken nesneler üzerinde fazla kullanılmayan renk seçilmeli ve ekran önündeki insan veya nesnenin seçilen anahtar renk ile aynı renkte bir şey barındırmaması gerekmektedir.Croma key çekim bittikten sonra (post-production) uygulanabileceği gibi çekim ile eş zamanlı(real-time) olarakta uygulanabilen bir tekniktir.Günlük olarak hepimizin şahit olabileceği bir örnek vermek gerekirse hava tahmin programlarını ele alabiliriz. Spiker hava tahminini sunarken genelde önünde hava durumunun bulunduğu bir coğrafi bölge haritası bulunur ve kendisi bu harita üzerinde belirli bölgeleri göstererek sunumunu yapar. Bu çekim eğer canlı olarak yapılıyorsa chroma key real-time olarak uygulanır. Aksi takdirde spiker greenscreen önünde sunumunu bitirdikten sonra chroma key uygulanacaktır.Chroma Key Gelişme AşamalarıChroma key tekniği günümüzdeki kullanılan hale gelene kadar çok aşamadan geçmiştir. İlk başlarda bu teknik ile hareketli görüntüler çekilemiyordu.Yani greenscreen teknolojisinin kullanıldığı sahnelerde kamera sabitti. Bunun sebebi ise arkaplanı ve önde duran aktörü saptamada sorun yaşanmasıydı.Ancak günümüzde arkaplana “+”, “x” işaretleriyle yada düzgün aralıklı noktalarla referans noktaları konulmakta ve bu yardımcı noktalar aracılığıyla bilgisayarlar, arkaplanı ve öndeki aktörü çok daha rahat bir şekilde saptayabilmektedir.Yukarıdaki resimde siyah noktalar aşağı veya yukarı doğru biraz meyilli yerleştirilmiştir. Bu sebeple kamera hareketinin de o yönde olacağını söyleyebiliriz. Dolayısıyla çekim kapsamına giren bu arkaplanlar öndeki aktörden daha kolay ayırt edilmektedir.Bu yöntemle kamera hareketli dahi olsa bu noktalar bilgisayar tarafından takip edilebilmekte ve kamera açısı kaybedilmemektedir.Croma Key Tekniğinde Dikkat Edilmesi Gerekenler Çekilen görüntülerde arkaplan rengi olarak yeşil kullanılıyorsa oyuncunuzun yeşil tonlarında bir şey giymemesi gereklidir. Bu özellik tüm renkler için geçerlidir. Cilalı yüzeyler ve cam gibi yansıtıcılığı yüksek nesneler arkaplanı yansıtabilirler. Bu yüzden parlak mücevherler, cilalı ayakkabılar ve yansıtıcı dekorlardan kaçınmak gerekmektedir. Çekimlerde, arkaplan perdesinin eşit olarak aydınlatılması önemli olduğu için çok sayıda ışık kullanmak gerekli olabilir. Bu yüzden dar alanlarda çekim yapmaktan kaçınılmalıdır. Oyuncunun perdeden mümkün olduğu kadar uzakta durması da kenarlarda oluşacak renk akmalarını önleyecektir. Bu yüzden profesyonel stüdyolarda çekim yapmak tercih edilmelidir. Çok ince detaylar “key”leme esnasında kaybolabilir. Bu nedenle mümkünse oyuncunun saçlarının toplu olması, bol ve saçaklı kıyafetlerden kaçınılması, hızlı hareketler yapılmaması ve sahnede aynı anda az kişi ve obje olması bu problemleri minimize eder."
    } 
  
]
